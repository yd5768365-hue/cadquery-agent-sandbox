# ml/models/geometry_encoder.py
"""
几何特征提取器
使用 3D CNN 或 PointNet 提取几何特征向量
"""

import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F

class Simple3DCNN(nn.Module):
    """简单的 3D CNN 几何编码器"""
    
    def __init__(self, input_shape=(64, 64, 64), feature_dim=128):
        super(Simple3DCNN, self).__init__()
        
        self.conv1 = nn.Conv3d(1, 32, kernel_size=3, padding=1)
        self.bn1 = nn.BatchNorm3d(32)
        self.pool1 = nn.MaxPool3d(2)
        
        self.conv2 = nn.Conv3d(32, 64, kernel_size=3, padding=1)
        self.bn2 = nn.BatchNorm3d(64)
        self.pool2 = nn.MaxPool3d(2)
        
        self.conv3 = nn.Conv3d(64, 128, kernel_size=3, padding=1)
        self.bn3 = nn.BatchNorm3d(128)
        self.pool3 = nn.MaxPool3d(2)
        
        # 计算展平后的维度
        final_size = input_shape[0] // 8
        self.flatten_dim = 128 * (final_size ** 3)
        
        self.fc1 = nn.Linear(self.flatten_dim, 512)
        self.dropout = nn.Dropout(0.5)
        self.fc2 = nn.Linear(512, feature_dim)
    
    def forward(self, x):
        # x shape: (batch, 1, D, H, W)
        x = F.relu(self.bn1(self.conv1(x)))
        x = self.pool1(x)
        
        x = F.relu(self.bn2(self.conv2(x)))
        x = self.pool2(x)
        
        x = F.relu(self.bn3(self.conv3(x)))
        x = self.pool3(x)
        
        x = x.view(x.size(0), -1)
        
        x = F.relu(self.fc1(x))
        x = self.dropout(x)
        x = self.fc2(x)
        
        return F.normalize(x, p=2, dim=1)  # L2 归一化


class GeometryFeatureExtractor:
    """几何特征提取器"""
    
    def __init__(self, model_path=None, resolution=64, feature_dim=128):
        self.resolution = resolution
        self.feature_dim = feature_dim
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        
        # 创建模型
        self.model = Simple3DCNN(
            input_shape=(resolution, resolution, resolution),
            feature_dim=feature_dim
        ).to(self.device)
        
        if model_path:
            self.load_model(model_path)
    
    def voxelize_step_file(self, step_file, resolution=None):
        """将 STEP 文件转换为体素网格"""
        resolution = resolution or self.resolution
        
        try:
            import cadquery as cq
            
            # 加载几何
            shape = cq.importers.importStep(step_file)
            
            # 获取包围盒
            bb = shape.val().BoundingBox()
            
            # 创建体素网格
            x_min, x_max = bb.xmin, bb.xmax
            y_min, y_max = bb.ymin, bb.ymax
            z_min, z_max = bb.zmin, bb.zmax
            
            # 计算体素大小
            x_size = (x_max - x_min) / resolution
            y_size = (y_max - y_min) / resolution
            z_size = (z_max - z_min) / resolution
            
            # 初始化体素网格
            voxels = np.zeros((resolution, resolution, resolution), dtype=np.float32)
            
            # 填充体素（简化版：采样点检测）
            for i in range(resolution):
                for j in range(resolution):
                    for k in range(resolution):
                        x = x_min + (i + 0.5) * x_size
                        y = y_min + (j + 0.5) * y_size
                        z = z_min + (k + 0.5) * z_size
                        
                        point = cq.Vector(x, y, z)
                        
                        # 检查点是否在几何内部
                        # 这里使用简化方法，实际应用需要更精确的算法
                        try:
                            is_inside = shape.val().isInside(point, tolerance=max(x_size, y_size, z_size))
                            voxels[i, j, k] = 1.0 if is_inside else 0.0
                        except:
                            voxels[i, j, k] = 0.0
            
            return voxels
        
        except Exception as e:
            print(f"体素化失败: {e}")
            return None
    
    def extract_features(self, step_file):
        """提取几何特征向量"""
        # 体素化
        voxels = self.voxelize_step_file(step_file)
        
        if voxels is None:
            return None
        
        # 转换为 PyTorch 张量
        voxels_tensor = torch.from_numpy(voxels).unsqueeze(0).unsqueeze(0).to(self.device)
        
        # 提取特征
        self.model.eval()
        with torch.no_grad():
            features = self.model(voxels_tensor)
        
        return features.cpu().numpy()[0]
    
    def save_model(self, filepath):
        """保存模型"""
        torch.save(self.model.state_dict(), filepath)
        print(f"模型已保存: {filepath}")
    
    def load_model(self, filepath):
        """加载模型"""
        self.model.load_state_dict(torch.load(filepath, map_location=self.device))
        self.model.eval()
        print(f"模型已加载: {filepath}")


# ml/models/geometry_search.py
"""
几何相似度搜索
使用 FAISS 向量库快速检索相似几何
"""

import faiss
import numpy as np
import json
from pathlib import Path

class GeometryVectorDatabase:
    """几何特征向量数据库"""
    
    def __init__(self, feature_dim=128, db_path="E:/DeepSeek_Work/ml/data/geometry_vectors.db"):
        self.feature_dim = feature_dim
        self.db_path = Path(db_path)
        
        # 创建 FAISS 索引
        self.index = faiss.IndexFlatL2(feature_dim)
        
        # 元数据
        self.metadata = []
        
        # 加载已有数据
        self._load_database()
    
    def add_geometry(self, feature_vector, metadata):
        """添加几何特征到数据库"""
        # 确保特征是正确的形状
        if feature_vector.shape[0] != self.feature_dim:
            raise ValueError(f"Feature dimension mismatch: expected {self.feature_dim}, got {feature_vector.shape[0]}")
        
        # 添加到 FAISS 索引
        feature_vector = feature_vector.reshape(1, -1).astype('float32')
        self.index.add(feature_vector)
        
        # 保存元数据
        self.metadata.append(metadata)
        
        # 保存数据库
        self._save_database()
    
    def search_similar(self, query_vector, k=5):
        """搜索相似几何"""
        if self.index.ntotal == 0:
            return []
        
        query_vector = query_vector.reshape(1, -1).astype('float32')
        
        # 搜索
        distances, indices = self.index.search(query_vector, min(k, self.index.ntotal))
        
        # 整理结果
        results = []
        for i, idx in enumerate(indices[0]):
            if idx < len(self.metadata):
                results.append({
                    'metadata': self.metadata[idx],
                    'distance': float(distances[0][i]),
                    'similarity': 1.0 / (1.0 + float(distances[0][i]))
                })
        
        return results
    
    def _save_database(self):
        """保存数据库"""
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        
        # 保存 FAISS 索引
        faiss.write_index(self.index, str(self.db_path.with_suffix('.index')))
        
        # 保存元数据
        with open(self.db_path.with_suffix('.json'), 'w', encoding='utf-8') as f:
            json.dump(self.metadata, f, ensure_ascii=False, indent=2)
    
    def _load_database(self):
        """加载数据库"""
        index_file = self.db_path.with_suffix('.index')
        metadata_file = self.db_path.with_suffix('.json')
        
        if index_file.exists():
            self.index = faiss.read_index(str(index_file))
        
        if metadata_file.exists():
            with open(metadata_file, 'r', encoding='utf-8') as f:
                self.metadata = json.load(f)
    
    def get_statistics(self):
        """获取统计信息"""
        return {
            'total_geometries': self.index.ntotal,
            'feature_dimension': self.feature_dim,
            'metadata_count': len(self.metadata)
        }


# ml/trainers/train_geometry_encoder.py
"""
训练几何编码器（可选）
如果有大量几何数据，可以训练专门的编码器
"""

def train_geometry_encoder(data_dir, epochs=50, batch_size=8):
    """训练几何编码器"""
    
    import torch
    from torch.utils.data import Dataset, DataLoader
    from ml.models.geometry_encoder import Simple3DCNN, GeometryFeatureExtractor
    
    # 这里需要准备训练数据
    # 实际应用中，可以使用对比学习或自编码器训练
    
    print("几何编码器训练（简化版）")
    print("注意：完整训练需要大量几何数据和 GPU")
    
    model = Simple3DCNN(feature_dim=128)
    
    # 训练逻辑...
    
    print("训练完成（示例）")
    
    return model


# 使用示例
if __name__ == "__main__":
    # 创建特征提取器
    extractor = GeometryFeatureExtractor(resolution=32, feature_dim=128)
    
    # 提取特征
    step_file = "E:/DeepSeek_Work/test/input/bracket.step"
    features = extractor.extract_features(step_file)
    
    if features is not None:
        print(f"特征向量维度: {features.shape}")
        
        # 添加到数据库
        db = GeometryVectorDatabase()
        db.add_geometry(features, {
            'file': step_file,
            'name': 'bracket',
            'timestamp': '2024-01-27'
        })
        
        # 搜索相似几何
        similar = db.search_similar(features, k=5)
        print(f"找到 {len(similar)} 个相似几何")